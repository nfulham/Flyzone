---
title: "Flyzone Optimization"
author: "Nate Fulham"
date: "2023-08-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(magrittr)
library(gtools)
```

```{r reference for rating information for shapes}
ref_info <- list(
  shape = c("Triangle", "Parallelogram", "Trapezoid"),
  shape_abbr = c("t", "p", "z"),
  str = c(4, 5, 1),
  flex = c(1, 5, 7),
  cost = c(2, 4, 6),
  cost_multipliers = c(
    m = 1,
    d = .5)
  )
```

```{r scoring function}

# This is the basic scoring function for either player
score_basic <- function(str = 0, flex = 0, cost, cost_multiplier) {
  return(str + flex - cost*cost_multiplier)
}

# Not much special here, just calculates the basics before sending it to score_basic
score_player_DI <- function(shape_vec, role, ref = ref_info) {
  
  if (role == "d" | role == "m") {} else {
    stop("role is not 'd' fr designer or 'm' for manufacturer. Please specify to calculate scores:")
  }
  
  if (role == "d") {
    basic_score_vec <- c(
    flexibility = sum(ref[["flex"]] * shape_vec), # calculating flexibility is based on ref_info
    cost = sum(ref[["cost"]] * shape_vec) # calculating cost is based on ref_info
    )
  }
  
  if (role == "m") {
    basic_score_vec <- c(
    strength = sum(ref[["str"]] * shape_vec), # calculating strength is based on ref_info
    cost = sum(ref[["cost"]] * shape_vec) # calculating cost is based on ref_info
    )
  }
  
  cost_multiply <- ref_info[["cost_multipliers"]][[role]]

  if (role == "d") {
    score_vec <- c(
    basic_score_vec,
    player_score = score_basic(flex = basic_score_vec[["flexibility"]],
                               cost = basic_score_vec[["cost"]],
                               cost_multiplier = cost_multiply))
  }
  
  if (role == "m") {
    score_vec <- c(
    basic_score_vec,
    player_score = score_basic(str = basic_score_vec[["strength"]],
                               cost = basic_score_vec[["cost"]],
                               cost_multiplier = cost_multiply))
  }
  return(score_vec)
}

score_player_FI <- function(shape_vec, role, ref = ref_info) {
  out <- score_basic(str = sum(ref[["str"]] * shape_vec),
                     flex = sum(ref[["flex"]] * shape_vec),
                     cost = sum(ref[["cost"]] * shape_vec), 
                     cost_multiplier = ref[["cost_multipliers"]][role])
  return(out)
}
```

```{r all shape permuatations}
n_shape <- 0:7
max_shapesum <- max(n_shape)
min_shapesum <- 4

exclusion_fn <- function(shape_vec, max = max_shapesum, min = min_shapesum) {
  if (sum(shape_vec) > max) {return(F)} # don't exceed shape maximum
  if (sum(shape_vec) < min) {return(F)} # you need at least 4 to fill in the figure
  if (sum(shape_vec) == min & (!all(shape_vec == c(3, 1, 0)) | !all(shape_vec == c(2, 1, 1)))) {return(F)}
  if (shape_vec[1] < 1) {return(F)} # solutions must include at least 1 triangle
  if (shape_vec[1] < 2 & any(sum(shape_vec) < 5, shape_vec[3] < 2)) {return(F)} # if there are less than 2 triangles, you need at least 5 shapes and 2 of them need to be trapezoids
  if (shape_vec[3] < 1 & shape_vec[1] < 3) {return(F)} 
  if (all(shape_vec[2:3] == c(0,0))) {return(F)}
  if (all(shape_vec == c(1,1,3)) | all(shape_vec == c(1,0,5))) {return(F)}
  return(T)
}

shape_perms <- gtools::permutations(length(n_shape), 3, v = n_shape, repeats.allowed = T) %>% 
  t %>% as.data.frame %>% 
  extract(map_lgl(., exclusion_fn)) %>% 
  set_rownames(c("t", "p", "z"))
```

```{r calculate scores}
# This determines scores for each player for each combination of shapes used to fill in the outline of the plane
all_scores <- cbind(shape_perms %>% t %>% as.data.frame %>% set_colnames(c("t", "p", "z")), 
                    # calculates designer scores for each permutation
                    map2_dfr(shape_perms, rep("d", ncol(shape_perms)), score_player_DI) %>% 
                      rename(d = player_score), 
                    # calculates manufacturer scores for each permutation
                    map2_dfr(shape_perms, rep("m", ncol(shape_perms)), score_player_DI) %>% 
                      rename(m = player_score) %>% dplyr::select(m)) %>% 
  # also calculate joint score, the ratio between the two, and the distance from 1
  mutate(d_FI = map2_dbl(shape_perms, "d", score_player_FI),
         m_FI = map2_dbl(shape_perms, "m", score_player_FI),
         team_score = d_FI + m_FI,
         team_score_rank = max(rank(team_score))+2 - rank(team_score, ties.method = "max"),
         ratio = d/m,
         ratio_dist_1 = abs(1 - ratio),
         id = paste0(t,p,z))

cors <- cor(all_scores %>% dplyr::select(where(is.numeric)))
```

```{r check integrative potential}
# this kind of plot gives a sense of what outomes are likely possible given at least the constraints we know
ggplot(all_scores, aes(d, m)) + geom_point(alpha = .4) +
  labs(title = "Relationship between role scores") +
  xlab("Designer Score") +
  ylab("Manufacturing Score")

ggplot(all_scores, aes(d_FI, m_FI)) + geom_point(alpha = .4) +
  labs(title = "Relationship between role scores") +
  xlab("Designer Score") +
  ylab("Manufacturing Score")
```

```{r test all ratios}
# I made these functions to test a bunch of different values for the cost measure to try to optimize for something very integrative. It essentially just runs the same thing as all the above but for different cost/budget numbers
change_ref_info <- function(multiplier, ref = ref_info) {
  ref_info[["cost"]] <- ref_info[["cost"]] * multiplier
  ref_info[["budget"]] <- ref_info[["budget"]] * multiplier
  return(ref_info)
}

calculate_scores <- function(new_ref_df, perm_df = shape_perms) {
  score_df <- cbind(perm_df %>% t %>% as.data.frame %>% set_colnames(c("t", "p", "z")),
                    map2_dfr(perm_df, rep("d", ncol(perm_df)), 
                             ~ score_player(shape_vec = .x, role = .y, ref = new_ref_df)) %>% 
                      rename(d = player_score), 
                    map2_dfr(perm_df, rep("m", ncol(perm_df)), 
                             ~ score_player(shape_vec = .x, role = .y, ref = new_ref_df)) %>% 
                      rename(m = player_score) %>% dplyr::select(m)) %>% 
    mutate(joint_score = d + m,
           ratio = d/m,
           ratio_dist_1 = abs(1 - ratio))
  return(score_df)
}


test_dfs <- map(c(seq(.1, 1, .1), seq(2, 10, 1)), change_ref_info) 
test <- test_dfs %>% 
  map(calculate_scores)
```

```{r}
plot_scores <- function(df) {
  ggplot(df, aes(d, m)) + geom_point(alpha = .3)
}

map(test, plot_scores)
```

